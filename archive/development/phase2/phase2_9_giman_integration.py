#!/usr/bin/env python3
"""Phase 2.9: GIMAN Integration - CNN + GRU Spatiotemporal Embeddings
=================================================================

Final integration of CNN + GRU spatiotemporal embeddings into the main GIMAN pipeline.
This replaces the placeholder embeddings with real spatiotemporal representations.

NO PLACEHOLDERS - Complete integration with real trained embeddings.

Key Integration Steps:
1. Load spatiotemporal embeddings
2. Create GIMAN-compatible embedding loader
3. Integration testing with main pipeline
4. Performance comparison (if baseline exists)
5. Final deployment preparation

Input: Generated spatiotemporal embeddings + GIMAN pipeline
Output: Fully integrated GIMAN with CNN + GRU embeddings
"""

import json
import logging
from datetime import datetime
from pathlib import Path

import numpy as np

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class GIMANSpatiotemporalIntegrator:
    """Integration manager for CNN + GRU spatiotemporal embeddings in GIMAN."""

    def __init__(self, embeddings_path: Path, base_dir: Path):
        """Initialize GIMAN integrator.

        Args:
            embeddings_path: Path to spatiotemporal embeddings JSON
            base_dir: Base directory for GIMAN project
        """
        self.embeddings_path = embeddings_path
        self.base_dir = base_dir
        self.embeddings_data = None
        self.metadata = None

        # Load embeddings
        self._load_spatiotemporal_embeddings()

        logger.info("GIMANSpatiotemporalIntegrator initialized")
        logger.info(f"Loaded {len(self.embeddings_data)} session embeddings")

    def _load_spatiotemporal_embeddings(self):
        """Load the generated spatiotemporal embeddings."""
        try:
            logger.info(
                f"Loading spatiotemporal embeddings from: {self.embeddings_path}"
            )

            with open(self.embeddings_path) as f:
                data = json.load(f)

            self.embeddings_data = data["embeddings"]
            self.metadata = data["metadata"]

            # Convert embeddings to numpy arrays for easier manipulation
            for session_key, embedding_list in self.embeddings_data.items():
                self.embeddings_data[session_key] = np.array(
                    embedding_list, dtype=np.float32
                )

            logger.info(f"âœ… Loaded {len(self.embeddings_data)} session embeddings")
            logger.info(f"Embedding dimension: {self.metadata['embedding_dim']}")
            logger.info(
                f"Generation timestamp: {self.metadata['generation_timestamp']}"
            )

        except Exception as e:
            logger.error(f"Failed to load spatiotemporal embeddings: {e}")
            raise

    def create_giman_embedding_loader(self, output_path: Path = None) -> Path:
        """Create a GIMAN-compatible embedding loader module.

        Args:
            output_path: Optional path for the embedding loader

        Returns:
            Path to the created embedding loader
        """
        logger.info("Creating GIMAN-compatible embedding loader...")

        if output_path is None:
            output_path = (
                self.base_dir
                / "src"
                / "giman_pipeline"
                / "spatiotemporal_embeddings.py"
            )

        # Create the embedding loader module
        loader_code = f"""#!/usr/bin/env python3
\"\"\"
Spatiotemporal Embedding Loader for GIMAN Pipeline
=================================================

This module provides spatiotemporal embeddings generated by the trained CNN + GRU model.
Replaces placeholder embeddings with real 256-dimensional spatiotemporal representations.

Generated on: {datetime.now().isoformat()}
Model: CNN3D + GRU Spatiotemporal Encoder
Embedding Dimension: 256
Number of Sessions: {len(self.embeddings_data)}
\"\"\"

import numpy as np
from typing import Dict, Optional, List
import logging

logger = logging.getLogger(__name__)

# Embedded spatiotemporal embeddings (generated from trained CNN + GRU model)
SPATIOTEMPORAL_EMBEDDINGS = {{{self._format_embeddings_for_code()}}}

# Metadata
EMBEDDING_METADATA = {{
    'embedding_type': 'spatiotemporal_cnn_gru',
    'embedding_dim': {self.metadata["embedding_dim"]},
    'num_sessions': {len(self.embeddings_data)},
    'generation_timestamp': '{self.metadata["generation_timestamp"]}',
    'model_architecture': 'CNN3D + GRU',
    'input_modality': 'sMRI_only',
    'training_patients': 7,
    'training_sessions': 14
}}

class SpatiotemporalEmbeddingProvider:
    \"\"\"Provider for CNN + GRU spatiotemporal embeddings.\"\"\"
    
    def __init__(self):
        \"\"\"Initialize the spatiotemporal embedding provider.\"\"\"
        self.embeddings = SPATIOTEMPORAL_EMBEDDINGS
        self.metadata = EMBEDDING_METADATA
        self.embedding_dim = self.metadata['embedding_dim']
        
        logger.info(f"SpatiotemporalEmbeddingProvider initialized")
        logger.info(f"Available sessions: {{list(self.embeddings.keys())}}")
    
    def get_embedding(self, patient_id: str, session: str) -> Optional[np.ndarray]:
        \"\"\"
        Get spatiotemporal embedding for a specific patient and session.
        
        Args:
            patient_id: Patient identifier
            session: Session identifier (e.g., 'baseline', 'followup_1')
            
        Returns:
            256-dimensional spatiotemporal embedding or None if not found
        \"\"\"
        session_key = f"{{patient_id}}_{{session}}"
        
        if session_key in self.embeddings:
            embedding = self.embeddings[session_key]
            logger.debug(f"Retrieved embedding for {{session_key}}: shape {{embedding.shape}}")
            return embedding
        else:
            logger.warning(f"No spatiotemporal embedding found for {{session_key}}")
            return None
    
    def get_all_embeddings(self) -> Dict[str, np.ndarray]:
        \"\"\"Get all available spatiotemporal embeddings.\"\"\"
        return self.embeddings.copy()
    
    def get_patient_embeddings(self, patient_id: str) -> Dict[str, np.ndarray]:
        \"\"\"
        Get all embeddings for a specific patient.
        
        Args:
            patient_id: Patient identifier
            
        Returns:
            Dictionary of session -> embedding for the patient
        \"\"\"
        patient_embeddings = {{}}
        
        for session_key, embedding in self.embeddings.items():
            if session_key.startswith(f"{{patient_id}}_"):
                session = session_key.split("_", 1)[1]  # Remove patient_id prefix
                patient_embeddings[session] = embedding
        
        return patient_embeddings
    
    def get_available_patients(self) -> List[str]:
        \"\"\"Get list of available patient IDs.\"\"\"
        patient_ids = set()
        for session_key in self.embeddings.keys():
            patient_id = session_key.split("_")[0]
            patient_ids.add(patient_id)
        
        return sorted(list(patient_ids))
    
    def get_embedding_statistics(self) -> Dict[str, float]:
        \"\"\"Get statistics about the spatiotemporal embeddings.\"\"\"
        all_embeddings = np.array(list(self.embeddings.values()))
        
        return {{
            'mean': float(np.mean(all_embeddings)),
            'std': float(np.std(all_embeddings)),
            'min': float(np.min(all_embeddings)),
            'max': float(np.max(all_embeddings)),
            'norm_mean': float(np.mean([np.linalg.norm(emb) for emb in all_embeddings]))
        }}

# Global instance for easy access
spatiotemporal_provider = SpatiotemporalEmbeddingProvider()

def get_spatiotemporal_embedding(patient_id: str, session: str = 'baseline') -> Optional[np.ndarray]:
    \"\"\"
    Convenience function to get spatiotemporal embedding.
    
    Args:
        patient_id: Patient identifier
        session: Session identifier
        
    Returns:
        256-dimensional spatiotemporal embedding
    \"\"\"
    return spatiotemporal_provider.get_embedding(patient_id, session)

def get_all_spatiotemporal_embeddings() -> Dict[str, np.ndarray]:
    \"\"\"Get all spatiotemporal embeddings.\"\"\"
    return spatiotemporal_provider.get_all_embeddings()

def get_embedding_info() -> Dict[str, Any]:
    \"\"\"Get information about the spatiotemporal embeddings.\"\"\"
    return {{
        'metadata': spatiotemporal_provider.metadata,
        'statistics': spatiotemporal_provider.get_embedding_statistics(),
        'available_patients': spatiotemporal_provider.get_available_patients(),
        'num_sessions': len(spatiotemporal_provider.embeddings)
    }}

if __name__ == "__main__":
    # Test the embedding provider
    print("ğŸ§  Spatiotemporal Embedding Provider Test")
    print("=" * 50)
    
    provider = SpatiotemporalEmbeddingProvider()
    info = get_embedding_info()
    
    print(f"Embedding dimension: {{info['metadata']['embedding_dim']}}")
    print(f"Number of sessions: {{info['num_sessions']}}")
    print(f"Available patients: {{info['available_patients']}}")
    print(f"Statistics: {{info['statistics']}}")
    
    # Test retrieval
    patient_id = info['available_patients'][0]
    embedding = get_spatiotemporal_embedding(patient_id, 'baseline')
    
    if embedding is not None:
        print(f"\\nTest embedding for patient {{patient_id}}_baseline:")
        print(f"  Shape: {{embedding.shape}}")
        print(f"  Mean: {{np.mean(embedding):.6f}}")
        print(f"  Std: {{np.std(embedding):.6f}}")
        print(f"  Norm: {{np.linalg.norm(embedding):.6f}}")
    
    print("\\nâœ… Spatiotemporal embeddings ready for GIMAN integration!")
"""

        # Write the embedding loader
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w") as f:
            f.write(loader_code)

        logger.info(f"ğŸ’¾ Created GIMAN embedding loader: {output_path}")
        return output_path

    def _format_embeddings_for_code(self) -> str:
        """Format embeddings for inclusion in Python code."""
        formatted_items = []

        for session_key, embedding in self.embeddings_data.items():
            # Convert numpy array to Python list string
            embedding_str = np.array2string(
                embedding, separator=", ", max_line_width=100, threshold=np.inf
            ).replace("\\n", "\\n    ")

            formatted_items.append(
                f'    "{session_key}": np.array({embedding_str}, dtype=np.float32)'
            )

        return ",\\n".join(formatted_items)

    def create_integration_test(self, output_path: Path = None) -> Path:
        """Create integration test for spatiotemporal embeddings in GIMAN."""
        logger.info("Creating GIMAN integration test...")

        if output_path is None:
            output_path = Path("./giman_integration_test.py")

        test_code = """#!/usr/bin/env python3
\"\"\"
GIMAN Integration Test - CNN + GRU Spatiotemporal Embeddings
==========================================================

Test integration of spatiotemporal embeddings with GIMAN pipeline.
Validates embedding loading, compatibility, and basic functionality.
\"\"\"

import sys
import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns

# Add GIMAN pipeline to path (adjust as needed)
# sys.path.append('/path/to/giman/src')

def test_embedding_loading():
    \"\"\"Test loading spatiotemporal embeddings.\"\"\"
    print("ğŸ§  Testing Spatiotemporal Embedding Loading")
    print("-" * 50)
    
    try:
        from giman_pipeline.spatiotemporal_embeddings import (
            spatiotemporal_provider, 
            get_spatiotemporal_embedding,
            get_embedding_info
        )
        
        # Get embedding info
        info = get_embedding_info()
        
        print(f"âœ… Loaded embedding provider")
        print(f"ğŸ“ Embedding dimension: {info['metadata']['embedding_dim']}")
        print(f"ğŸ”¢ Number of sessions: {info['num_sessions']}")
        print(f"ğŸ‘¥ Available patients: {info['available_patients']}")
        
        # Test individual embedding retrieval
        patient_id = info['available_patients'][0]
        embedding = get_spatiotemporal_embedding(patient_id, 'baseline')
        
        if embedding is not None:
            print(f"\\nâœ… Retrieved embedding for {patient_id}_baseline")
            print(f"   Shape: {embedding.shape}")
            print(f"   Mean: {np.mean(embedding):.6f}")
            print(f"   Std: {np.std(embedding):.6f}")
            print(f"   Norm: {np.linalg.norm(embedding):.6f}")
        
        return True
        
    except Exception as e:
        print(f"âŒ Error loading embeddings: {e}")
        return False

def test_embedding_quality():
    \"\"\"Test quality and distribution of spatiotemporal embeddings.\"\"\"
    print("\\nğŸ“Š Testing Embedding Quality")
    print("-" * 50)
    
    try:
        from giman_pipeline.spatiotemporal_embeddings import get_all_spatiotemporal_embeddings
        
        embeddings = get_all_spatiotemporal_embeddings()
        
        # Convert to array for analysis
        embedding_matrix = np.array(list(embeddings.values()))
        
        print(f"Embedding matrix shape: {embedding_matrix.shape}")
        print(f"Global statistics:")
        print(f"  Mean: {np.mean(embedding_matrix):.6f}")
        print(f"  Std: {np.std(embedding_matrix):.6f}")
        print(f"  Min: {np.min(embedding_matrix):.6f}")
        print(f"  Max: {np.max(embedding_matrix):.6f}")
        
        # Check for reasonable distribution
        mean_abs = np.mean(np.abs(embedding_matrix))
        print(f"  Mean absolute value: {mean_abs:.6f}")
        
        if 0.001 < mean_abs < 0.1:
            print("âœ… Embedding distribution looks reasonable")
        else:
            print("âš ï¸  Embedding distribution may need attention")
        
        # Create distribution plot
        plt.figure(figsize=(12, 4))
        
        plt.subplot(1, 3, 1)
        plt.hist(embedding_matrix.flatten(), bins=50, alpha=0.7)
        plt.title('Embedding Value Distribution')
        plt.xlabel('Value')
        plt.ylabel('Frequency')
        
        plt.subplot(1, 3, 2)
        embedding_norms = [np.linalg.norm(emb) for emb in embedding_matrix]
        plt.hist(embedding_norms, bins=20, alpha=0.7)
        plt.title('Embedding Norm Distribution')
        plt.xlabel('L2 Norm')
        plt.ylabel('Frequency')
        
        plt.subplot(1, 3, 3)
        embedding_means = [np.mean(emb) for emb in embedding_matrix]
        plt.hist(embedding_means, bins=20, alpha=0.7)
        plt.title('Per-Embedding Mean Distribution')
        plt.xlabel('Mean Value')
        plt.ylabel('Frequency')
        
        plt.tight_layout()
        plt.savefig('spatiotemporal_embedding_analysis.png', dpi=300, bbox_inches='tight')
        plt.close()
        
        print("ğŸ“ˆ Saved embedding analysis plot: spatiotemporal_embedding_analysis.png")
        
        return True
        
    except Exception as e:
        print(f"âŒ Error analyzing embeddings: {e}")
        return False

def test_patient_consistency():
    \"\"\"Test consistency of embeddings within patients.\"\"\"
    print("\\nğŸ‘¥ Testing Patient Embedding Consistency")
    print("-" * 50)
    
    try:
        from giman_pipeline.spatiotemporal_embeddings import spatiotemporal_provider
        
        available_patients = spatiotemporal_provider.get_available_patients()
        
        for patient_id in available_patients:
            patient_embeddings = spatiotemporal_provider.get_patient_embeddings(patient_id)
            
            if len(patient_embeddings) > 1:
                # Calculate similarity between sessions for this patient
                sessions = list(patient_embeddings.keys())
                emb1 = patient_embeddings[sessions[0]]
                emb2 = patient_embeddings[sessions[1]]
                
                # Cosine similarity
                cosine_sim = np.dot(emb1, emb2) / (np.linalg.norm(emb1) * np.linalg.norm(emb2))
                
                # L2 distance
                l2_dist = np.linalg.norm(emb1 - emb2)
                
                print(f"Patient {patient_id}: {len(patient_embeddings)} sessions")
                print(f"  Cosine similarity: {cosine_sim:.4f}")
                print(f"  L2 distance: {l2_dist:.4f}")
                
                # Reasonable similarity expected for same patient
                if 0.7 < cosine_sim < 0.99:
                    print("  âœ… Reasonable inter-session similarity")
                else:
                    print("  âš ï¸  Unusual inter-session similarity")
        
        return True
        
    except Exception as e:
        print(f"âŒ Error testing patient consistency: {e}")
        return False

def main():
    \"\"\"Run complete integration test.\"\"\"
    print("\\n" + "="*60)
    print("ğŸš€ GIMAN SPATIOTEMPORAL EMBEDDING INTEGRATION TEST")
    print("="*60)
    
    tests = [
        ("Embedding Loading", test_embedding_loading),
        ("Embedding Quality", test_embedding_quality),
        ("Patient Consistency", test_patient_consistency)
    ]
    
    results = []
    for test_name, test_func in tests:
        print(f"\\nğŸ” Running: {test_name}")
        result = test_func()
        results.append((test_name, result))
    
    # Summary
    print("\\n" + "="*60)
    print("ğŸ“‹ INTEGRATION TEST SUMMARY")
    print("="*60)
    
    passed = 0
    for test_name, result in results:
        status = "âœ… PASS" if result else "âŒ FAIL"
        print(f"{status} {test_name}")
        if result:
            passed += 1
    
    print(f"\\nResults: {passed}/{len(tests)} tests passed")
    
    if passed == len(tests):
        print("\\nğŸ‰ All tests passed! Spatiotemporal embeddings ready for GIMAN!")
        return True
    else:
        print(f"\\nâš ï¸  {len(tests) - passed} test(s) failed. Please check integration.")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""

        with open(output_path, "w") as f:
            f.write(test_code)

        logger.info(f"ğŸ’¾ Created integration test: {output_path}")
        return output_path

    def create_deployment_guide(self, output_path: Path = None) -> Path:
        """Create deployment guide for GIMAN integration."""
        logger.info("Creating GIMAN deployment guide...")

        if output_path is None:
            output_path = Path("./GIMAN_DEPLOYMENT_GUIDE.md")

        guide_content = f"""# GIMAN Spatiotemporal Embedding Deployment Guide

## ğŸ¯ Overview

This guide covers the deployment of CNN + GRU spatiotemporal embeddings into the main GIMAN pipeline.

**Generated:** {datetime.now().isoformat()}  
**Model:** CNN3D + GRU Spatiotemporal Encoder  
**Embedding Dimension:** 256  
**Training Data:** 7 patients, 14 sessions  

## ğŸ“ Files Generated

### Core Integration Files
- `spatiotemporal_embeddings.py` - Main embedding provider module
- `giman_integration_test.py` - Integration testing script
- `GIMAN_DEPLOYMENT_GUIDE.md` - This deployment guide

### Embedding Data Files
- `spatiotemporal_embeddings.npz` - NumPy format (primary)
- `spatiotemporal_embeddings.json` - JSON format (readable)
- `spatiotemporal_embeddings.csv` - CSV format (spreadsheet)
- `giman_spatiotemporal_embeddings.json` - GIMAN-compatible format

### Training Artifacts
- `best_model.pth` - Trained CNN + GRU model
- `training_results.json` - Training metrics and configuration
- `loss_curves.png` - Training progress visualization

## ğŸš€ Deployment Steps

### Step 1: Copy Embedding Provider
```bash
# Copy the embedding provider to your GIMAN pipeline
cp spatiotemporal_embeddings.py /path/to/giman/src/giman_pipeline/
```

### Step 2: Update GIMAN Pipeline
Modify your main GIMAN pipeline to use spatiotemporal embeddings:

```python
# In your GIMAN pipeline code
from giman_pipeline.spatiotemporal_embeddings import get_spatiotemporal_embedding

# Replace placeholder embedding calls with:
def get_patient_embedding(patient_id: str, session: str = 'baseline'):
    embedding = get_spatiotemporal_embedding(patient_id, session)
    
    if embedding is not None:
        return embedding
    else:
        # Fallback to previous method if needed
        return get_previous_embedding_method(patient_id, session)
```

### Step 3: Run Integration Tests
```bash
# Run the integration test
python giman_integration_test.py
```

### Step 4: Validate Performance
Compare performance with baseline GIMAN pipeline:
- Embedding quality metrics
- Downstream task performance
- Processing speed

## ğŸ“Š Embedding Specifications

### Technical Details
- **Architecture:** 3D CNN (4 blocks) + Bidirectional GRU (2 layers)
- **Input:** Single modality (sMRI only), 96Â³ voxels
- **Output:** 256-dimensional spatiotemporal embedding
- **Training:** 30 epochs, Adam optimizer, early stopping
- **Validation Loss:** 0.0279 (final best)

### Patient Coverage
**Available Patients:**
{sorted([k.split("_")[0] for k in self.embeddings_data.keys() if "_" in k])}

**Available Sessions:**
{sorted(set([k.split("_", 1)[1] for k in self.embeddings_data.keys() if "_" in k]))}

### Embedding Statistics
{self._get_embedding_statistics()}

## ğŸ”§ Configuration Options

### Embedding Provider Configuration
```python
from giman_pipeline.spatiotemporal_embeddings import SpatiotemporalEmbeddingProvider

# Initialize provider
provider = SpatiotemporalEmbeddingProvider()

# Get embedding info
info = provider.get_embedding_statistics()
patients = provider.get_available_patients()
```

### Alternative Embedding Formats
If you need different embedding formats:

```python
# Load from NumPy format
import numpy as np
data = np.load('spatiotemporal_embeddings.npz')
embeddings = data['embeddings']
patient_ids = data['patient_ids']

# Load from JSON format  
import json
with open('spatiotemporal_embeddings.json', 'r') as f:
    data = json.load(f)
    embeddings = data['embeddings']
```

## ğŸ§ª Testing and Validation

### Basic Functionality Test
```python
from giman_pipeline.spatiotemporal_embeddings import get_spatiotemporal_embedding

# Test embedding retrieval
embedding = get_spatiotemporal_embedding('100232', 'baseline')
print(f"Embedding shape: {{embedding.shape}}")
print(f"Embedding norm: {{np.linalg.norm(embedding)}}")
```

### Integration Test
```bash
# Run comprehensive integration test
python giman_integration_test.py

# Check test outputs
ls -la spatiotemporal_embedding_analysis.png
```

## ğŸ“ˆ Performance Expectations

### Embedding Quality
- **Dimensionality:** 256 (spatiotemporal representation)
- **Distribution:** Well-normalized, mean â‰ˆ 0, std â‰ˆ 0.014
- **Consistency:** High intra-patient similarity across sessions
- **Coverage:** All 7 expanded dataset patients included

### Computational Requirements
- **Memory:** ~2MB for all embeddings (in memory)
- **Speed:** Instant retrieval (pre-computed)
- **Storage:** ~5MB total for all formats

## ğŸ” Troubleshooting

### Common Issues

1. **Import Error:** 
   ```
   ModuleNotFoundError: No module named 'giman_pipeline.spatiotemporal_embeddings'
   ```
   **Solution:** Ensure `spatiotemporal_embeddings.py` is in the correct path

2. **Missing Embedding:**
   ```
   No spatiotemporal embedding found for patient_session
   ```
   **Solution:** Check available patients with `provider.get_available_patients()`

3. **Shape Mismatch:**
   ```
   Expected embedding dimension X, got 256
   ```
   **Solution:** Update downstream code to handle 256-dimensional embeddings

### Validation Commands
```bash
# Check embedding provider
python -c "from giman_pipeline.spatiotemporal_embeddings import get_embedding_info; print(get_embedding_info())"

# Validate all embeddings load correctly
python -c "from giman_pipeline.spatiotemporal_embeddings import get_all_spatiotemporal_embeddings; print(len(get_all_spatiotemporal_embeddings()))"
```

## ğŸ‰ Deployment Checklist

- [ ] Copy `spatiotemporal_embeddings.py` to GIMAN pipeline
- [ ] Update GIMAN code to use new embedding provider
- [ ] Run integration tests successfully
- [ ] Validate embedding dimensions match expectations
- [ ] Test with sample patients/sessions
- [ ] Compare performance with baseline (if available)
- [ ] Update documentation and user guides
- [ ] Deploy to production environment

## ğŸ“ Support

For issues with spatiotemporal embedding integration:

1. Check the integration test output
2. Validate embedding statistics match expected ranges
3. Ensure all required patients/sessions are available
4. Compare with baseline GIMAN performance

## ğŸ”„ Future Updates

To update embeddings with new training data:

1. Retrain CNN + GRU model with expanded dataset
2. Run Phase 2.8 embedding generation
3. Replace `spatiotemporal_embeddings.py` with new version
4. Run integration tests to validate compatibility
5. Update deployment documentation

---

**Generated by GIMAN Spatiotemporal Integration Pipeline**  
**Timestamp:** {datetime.now().isoformat()}
"""

        with open(output_path, "w") as f:
            f.write(guide_content)

        logger.info(f"ğŸ“‹ Created deployment guide: {output_path}")
        return output_path

    def _get_embedding_statistics(self) -> str:
        """Get formatted embedding statistics for documentation."""
        all_embeddings = np.array(list(self.embeddings_data.values()))

        stats = {
            "mean": float(np.mean(all_embeddings)),
            "std": float(np.std(all_embeddings)),
            "min": float(np.min(all_embeddings)),
            "max": float(np.max(all_embeddings)),
            "norm_mean": float(
                np.mean([np.linalg.norm(emb) for emb in all_embeddings])
            ),
        }

        return f"""- **Global Mean:** {stats["mean"]:.6f}
- **Global Std:** {stats["std"]:.6f}
- **Value Range:** [{stats["min"]:.6f}, {stats["max"]:.6f}]
- **Average Norm:** {stats["norm_mean"]:.6f}"""


def main():
    """Main integration function."""
    print("\\n" + "=" * 60)
    print("ğŸ”— GIMAN SPATIOTEMPORAL INTEGRATION - PHASE 2.9")
    print("=" * 60)

    # Setup paths
    base_dir = Path(
        "/Users/blair.dupre/Library/CloudStorage/GoogleDrive-dupre.blair92@gmail.com/My Drive/CSCI FALL 2025"
    )
    embeddings_path = Path("./embeddings_output/giman_spatiotemporal_embeddings.json")

    # Verify inputs
    if not embeddings_path.exists():
        raise FileNotFoundError(
            f"Spatiotemporal embeddings not found: {embeddings_path}"
        )

    # Initialize integrator
    integrator = GIMANSpatiotemporalIntegrator(embeddings_path, base_dir)

    # Create integration files
    logger.info("Creating GIMAN integration files...")

    # 1. Create embedding loader
    embedding_loader_path = integrator.create_giman_embedding_loader()

    # 2. Create integration test
    integration_test_path = integrator.create_integration_test()

    # 3. Create deployment guide
    deployment_guide_path = integrator.create_deployment_guide()

    # Final summary
    print("\\n" + "=" * 60)
    print("âœ… GIMAN INTEGRATION COMPLETE - PHASE 2.9")
    print("=" * 60)
    print("ğŸ§  Spatiotemporal embeddings integrated")
    print("ğŸ“ Embedding dimension: 256")
    print(
        f"ğŸ‘¥ Patients covered: {len(set([k.split('_')[0] for k in integrator.embeddings_data.keys()]))}"
    )
    print(f"ğŸ“Š Sessions available: {len(integrator.embeddings_data)}")

    print("\\nğŸ“ Integration Files Created:")
    print(f"  ğŸ”§ Embedding Provider: {embedding_loader_path.name}")
    print(f"  ğŸ§ª Integration Test: {integration_test_path.name}")
    print(f"  ğŸ“‹ Deployment Guide: {deployment_guide_path.name}")

    print("\\nğŸš€ Next Steps:")
    print("1. Copy spatiotemporal_embeddings.py to your GIMAN pipeline")
    print("2. Update GIMAN code to use spatiotemporal embeddings")
    print("3. Run giman_integration_test.py to validate")
    print("4. Follow GIMAN_DEPLOYMENT_GUIDE.md for full deployment")

    print("\\nğŸ‰ CNN + GRU spatiotemporal embeddings ready for GIMAN!")

    return {
        "embedding_loader": embedding_loader_path,
        "integration_test": integration_test_path,
        "deployment_guide": deployment_guide_path,
        "num_embeddings": len(integrator.embeddings_data),
    }


if __name__ == "__main__":
    try:
        results = main()
        print("\\nâœ… Phase 2.9 Complete - GIMAN integration ready!")

    except Exception as e:
        logger.error(f"âŒ GIMAN integration failed: {e}")
        raise
